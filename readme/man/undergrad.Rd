% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/readme2_undergrad.R
\name{undergrad}
\alias{undergrad}
\title{undergrad}
\usage{
undergrad(
  documentText,
  wordVecs = NULL,
  word_quantiles = c(0.1, 0.5, 0.9),
  reattempt = T,
  reattempt_regex = list(c("\\\\#", ""), c("#\\\\S+", "<hashtag>"), c("[[:punct:]]+",
    ""), c("ing\\\\b", ""), c("s\\\\b", ""), c("ed\\\\b", ""), c("ies\\\\b", "y")),
  unique_terms = T,
  verbose = T,
  numericization_method = "vector_summaries",
  textEmbed_control = list(tokenizer_parallelism = T, model = "bert-base-uncased", layers
    = -2L)
)
}
\arguments{
\item{documentText}{A vector in which each entry corresponds to a ``clean'' document.
Note that the function will take as a ``word'' all whitespace-separated elements in each vector entry. For example,
\code{"star."} would have to have an exact analogue in the vector corpus, otherwise
it will be dropped in the calculations.}

\item{wordVecs}{A matrix where each row denotes a word and each column a word vector. Words should be stored as the rownames of the matrix.}

\item{word_quantiles}{A numeric vector denoting the quantiles (0-1) used to summarize each word vector dimension. Defaults to 0.10th, 0.50th and 0.90th quantiles.}

\item{reattempt}{If TRUE, attempts to match terms missing from the wordVec corpus with alternate representations.}

\item{reattempt_regex}{A list of character vectors containing regular expression pairs to be used for generating alternate representations of words to attempt
to match with the wordVec corpus when terms initially cannot be matched. Order matters.}

\item{unique_terms}{If TRUE, removes duplicate terms from each document - each document is represented only by the presence or absence of a term.}

\item{verbose}{If TRUE, prints updates as function runs}

\item{numericization_method}{Determines whether word vector summaries are used for documents (faster, specified by
`numericization_method = "vector_summaries"`), or whether transformer-based document features are used (slower, specified by `numericization_method = "transformer_based"`)}

\item{textEmbed_control}{A list with elements denoting the parameters passed to `text::textEmbed` if `numericization_method = "transformer_based"`. Default is
`list(tokenizer_parallelism = T,
      model = "bert-base-uncased",
      layers = -2L)`)}
}
\value{
A data.frame consisting of the \code{word_quantiles} quantiles of the word vectors by document.
 Each row corresonds to a document, and the columns to a particular summary of a particular word vector dimension.
}
\description{
Preprocessing for \code{readme} function - creates a document-feature matrix
(saved as a data frame in output) to be passed to \code{readme}. Users can either input word-specific vectors
using the \code{wordVecs_corpus} or \code{wordVecs_corpusPointer} parameters. Primarily intended for users
wanting control over the pre-processing protocol. \code{numericization_method} controls whether word vector summaries
(the default, \code{numericization_method = "vector_based"}) or transformer-based document features (if using \code{"transformer_based"}).
}
\examples{
#set seed
set.seed(1)

#Generate synthetic word vector corpus.
my_wordVecs <- matrix(rnorm(11*50), ncol = 50)
row.names(my_wordVecs) <- c("the","true", "thine", "stars", "are" ,
                              "fire", ".", "to", "own", "self", "be")

#Setup ``documents''
my_documentText <- c(
"the stars are fire .", #document 1
"to thine own self be true ", #document 2
"true stars be true ." #document 3
)

#Get document-level word vector summaries.
my_dfm <- undergrad(documentText = my_documentText, wordVecs = my_wordVecs)
print( my_dfm )

}
